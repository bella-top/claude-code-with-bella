# Claude Code让AI编程真正落地

## 一、分享目的
- 了解Claude Code能帮我们解决哪些实际编程问题
- 深入理解Claude Code的核心优势和设计理念
- 掌握Claude Code的最佳实践和高效使用方法

## 二、AI Coding的最终选择：Claude Code

### 2.1 为什么关注AI Coding

- 研发同学日常核心工作就是coding，编程效率提升直接转化为工作价值。
- Coding是一个相对标准化的垂直领域，有明确的语法规则和逻辑结构。这个领域的问题更容易用AI解决。
- Coding工作输入输出明确：需求→代码的映射相对清晰
- 以上原因促使AI Coding市场很活跃，工具已经相对成熟，学习成本最低。

### 2.2 我的AI Coding探索历程

- Windsurf最早期用户：早期的windsurf在当时很惊艳，UI体验、coding质量、价格都不错，但是初期出现执行异常的情况略多，复杂任务的理解一般，并且后来价格提高
- Bella开源生态建设，期望AI解决社区issues，调研开源的AI-coding项目gpt-engineer,continue.dev,MetaGPT等
- 在调研众多开源项目的基础上，实现了bella-issues-bot专注于解决GitHub社区的issues
- google推出Jules，免费且基于planning，擅长解决复杂问题，执行时间很长，但是从中体会了异步编程的理念

### 2.3 Claude Code的使用体验好在哪里？
- 对复杂问题的理解性更好，执行速度比Jules快
- 生成的代码风格与整个项目更一致
- 执行过程中的容错率更高，几乎不会出现执行异常导致本次任务失败的请情况
- 既有cli支持本地开发，又集成了GitHub的code review和issues处理等功能
- 生成的代码准确率高，几乎在不修改的情况下都可以直接执行
- 可以直接集成公司的统一网关Bella-Openapi，团队可统一AI工具，更有利于使用经验的复制和沉淀

### 2.4 Bella Openapi在Claude Code的集成上做了什么？
- 实现了Claude Code依赖的 `/v1/messsages` 接口
- 所有在Bella-Openapi中接入的LLM协议均可使用Claude Code，不仅仅支持Claude系列模型，同时支持了Openai全系列、Gemini、DeepSeek、Qwen、Doubao等主流模型。
- 可以为Claude Code使用单独的Apikey，控制成本，且每次请求产生的费用开销在日志中清晰可见
- 企业级用户可以在使用统一网关的同时，享受最强Code Agent的全部特性

## 三、深入理解Claude Code为什么更好

### 3.1 Agent设计理念
[Claude Code的单Agent设计](../../agent_design.md)


### 3.2 合理的codebase管理
[Claude Code与Cursor的codebase对比](../../codebase_Cursor_vs_Claude.md)

## 四、快速使用

### 4.1 本地coding
[Claude-Code-Cli快速使用攻略](../../README.md)

### 4.2 GitHub集成
[Claude-Code-GitHub快速集成攻略](../../README_GITHUB_ACTION.md)

## 五、让Claude Code更好地为你工作

### 5.1 如何分解任务

**按复杂度分层**
- **简单任务**：单文件修改、bug修复、代码格式化
    - 直接描述问题和期望结果
    - 例：`修复这个空指针异常，在user为null时返回默认值`

- **中等任务**：功能实现、API开发、测试编写
    - 描述功能需求和约束条件
    - 提供相关的数据结构和接口定义
    - 例：`实现用户登录接口，支持邮箱和手机号，返回JWT token`

- **复杂任务**：架构重构、系统集成、性能优化
    - 分解为多个独立的子任务
    - 明确各模块间的依赖关系
    - 提供系统整体的上下文信息

**任务分解的最佳实践**
1. **单一职责**：每个任务只专注一个核心功能
2. **可验证**：任务完成后有明确的验证标准
3. **有边界**：明确哪些文件和模块会被影响
4. **递进式**：从基础功能到复杂特性逐步推进

### 5.2 任务分解案例
**Bella-Openapi将Lark的文档解析封装为能力点**
- 实现Document Parse能力点：
  - 抽象适配器接口
  - 渠道特性定义
  - 日志上报逻辑
- 实现Lark协议的适配器
  - Lark API调用的流程编排
  - Lark API的调用实现
  - 请求和响应的协议转换

#### 5.2.1 分析
一个大任务拆分为两个子任务，每个子任务又可以继续拆分。
对于`实现Document Parse能力点`，**如果了解项目的架构，实现很快，代码量小，可以手动实现；如果不了解项目，可以让Claude Code分析能力点如何实现，或者直接让Claude Code参照其他能力点实现。**
对于`实现Lark协议的适配器`：
 - `Lark API调用的流程编排`这一子任务更适合手动完成，因为开发者需要了解Lark的接口功能。当然，在调研Lark的时候依然可以借助AI。
 - `Lark API的调用实现`是比较纯粹的简单任务，在实现接口调用的时候，可以只写mock调用，将各个API的请求示例发给Claude Code让其实现。
 - `请求和响应的协议转换` 代码量较多，因为文档解析的协议很复杂，是最应该借助AI完成的，可以将协议复制给Claude Code，让其完成。

#### 5.2.2 针对此案例分析高效完成任务的要素
- **熟悉AI**：对AI Coding工具能力边界的了解程度
- **思路清晰**: 自己已经做好了清晰的planning，知道这件事应该如何完成，planning的过程也可以借助AI
- **熟悉项目**：对项目架构的了解程度，不熟悉的情况下，可以借助AI Coding工具或者Deep wiki等快速熟悉
- **快速调研**：对于新事物Lark API能够快速理解怎么用，怎么借助其实现自己的目的，这一工作同样可以借助AI完成
- **Debug能力**：对Claude Code生成的代码能快速理解，debug时输出不符合预期，能够快速判断哪里出错，直接告诉Claude Code哪里有问题；如果分析不出来可以向AI描述当前输出和期望输出的差异

### 5.2.3 哪些任务适合交给它

**✅ 高度适合的任务**
- **代码生成**：根据需求文档生成业务逻辑代码
- **Bug修复**：根据错误信息和堆栈追踪修复问题
- **测试编写**：为现有代码生成单元测试和集成测试
- **代码重构**：优化代码结构，提高可读性和可维护性
- **API实现**：根据接口定义实现后端服务
- **数据处理**：编写数据转换、清洗、分析脚本

**⚠️ 需要谨慎的任务**
- **架构设计**：需要人工review和决策
- **安全相关代码**：需要额外的安全审查
- **系统性能相关的代码**：需要性能测试验证
- **第三方集成**：需要详细明确的文档以及实际调试和联调

**❌ 不适合的任务**
- **需求分析**：需要业务理解和用户交互
- **技术选型**：需要综合考虑团队、项目、成本等因素
- **生产环境操作**：需要人工确认和监控

### 5.3 使用者需要具备哪些能力
- **深度了解AI**：对所用的AI工具的能力有深度的了解
- **思路清晰**：目标清晰，清楚自己要什么，并且对实现路径有清晰的把握
- **系统设计能力**：对整体架构和模块关系有清晰认知，能够合理分解任务
- **代码Review能力**：能够识别生成代码的问题，包括逻辑错误、性能问题、安全隐患
- **Debug能力**：当生成的代码出现问题时，能够快速定位和修复
- **需求理解能力**：能够将模糊的业务需求转化为清晰的技术实现要求
- **工程实践经验**：了解项目的编码规范、测试要求、部署流程等

### 5.4 核心价值分析
- **扩大能力边界**：对某种编程语言或框架的熟悉程度没有那么重要，上手新的编程语言成本降低，全栈工程师的门槛降低
- **工作效率提升**：虽然没有完全意义的实现`所想即所得`，但是已经很大程度的解放双手
- **解放个人时间**：有更多的思考时间，去分析当下的问题，思考自己能做什么、能改变什么、怎么去做、评估实现成本和收益
- **个人和团队价值提升**：对于个人，以上三点形成了正反馈循环；对于团队，每一次小的探索积累都可以转化为团队的沉淀，日积月累可能会有更大的收获

### 5.5 使用总结
- 任务拆解：对复杂任务的实现步骤进行拆解，如果不清楚应该怎么做，可以先让AI来分析需求
- 提供清晰的上下文：至少需要明确的需求，可以通过`@filename`提供相关文件，加速实现速度
- 明确约束条件：比如按照xxx的实现、可选择的技术栈和中间件、性能要求等

### 5.6 案例分享
[Lark文档解析支持文件删除Issues](https://github.com/LianjiaTech/bella-openapi/issues/117)

**背景**：实现文档解析服务的任务管理，支持文件删除功能

**实现过程**：
1. **初版实现**：Claude Code使用数据库实现任务管理
    - 功能完整，但引入了额外的存储依赖
    - 对于简单场景过于重量级

2. **优化方向**：基于反馈，改为内存实现
    - 降低系统复杂度，减少外部依赖
    - 提高响应速度，简化部署

3. **问题识别**：内存方案存在服务重启丢失任务的风险
    - 方案一：优雅关闭，等待任务完成（影响发布速度）
    - 方案二：引入Redis持久化（平衡性能和可靠性）

4. **最终实现**：选择Redis方案，Claude Code快速完成实现
    - 既保证了任务的持久性，又不影响服务发布流程
    - 代码质量高，几乎无需修改直接可用

**经验总结**：
- Claude Code能够理解复杂的业务逻辑和技术权衡
- 通过多轮对话，能够不断优化方案
- 生成的代码质量高，符合项目整体风格


## 六、立即行动
- 根据[教程](../../README.md)安装配置Claude Code，本地体验提出问题，
- 为支持项目：[ClaudeCode集成Bella](https://github.com/bella-top/claude-code-with-bella)，[Bella Openapi](https://github.com/LianjiaTech/bella-openapi)点赞

## 七、Q&A和讨论
**核心观点总结**
- **Claude Code功能优秀**：对比其他AI Coding工具，在综合能力和全面性上优势明显
- **Claude Code设计优秀**：Claude Code的优秀能力，与它的Agent设计理念以及codebase设计密不可分
- **使用者的能力要求**：用好AI Coding工具，需要具备软件工程师素养，有明确的目标和清晰的思路
- **不止步于coding**：AI Coding除了带来工作效率的提升外，也给个人和团队带来了更多的可能性，要逐渐地以生产力革命的视角感受和理解AI带来的改变
